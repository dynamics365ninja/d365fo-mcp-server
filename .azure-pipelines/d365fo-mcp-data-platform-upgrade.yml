# Azure Pipeline for D365 Platform Upgrade
# This pipeline combines standard and custom metadata extraction in single stage
# Use this after Microsoft releases new D365 version
# Pipeline automatically downloads latest version from NuGet (10.0.* and 7.0.*)

trigger: none  # Manual execution only

pool:
  vmImage: 'windows-latest'  # Windows required for NuGet

variables:
  - group: xpp-mcp-server-config
  - name: nodeVersion
    value: '22.x'
  - name: METADATA_PATH
    value: './extracted-metadata'
  - name: DB_PATH
    value: './data/xpp-metadata.db'
  - name: NugetConfigsPath
    value: '$(Build.SourcesDirectory)\src\d365fo\build\MsApplFeeds'
  - name: NugetsPath
    value: '$(Pipeline.Workspace)\NuGets'
  - name: NugetsPathNoVer
    value: '$(Pipeline.Workspace)\NuGetsNoVer'
  - name: ToolsPackage
    value: 'Microsoft.Dynamics.AX.Platform.CompilerPackage'
  - name: MsAppVersion
    value: 'latest'

stages:
  # ============================================================================
  # Single Stage: Complete Platform Upgrade
  # ============================================================================
  - stage: PlatformUpgrade
    displayName: 'Complete Platform Upgrade'
    jobs:
      - job: UpgradeJob
        displayName: 'Extract Standard ‚Üí Extract Custom ‚Üí Build ‚Üí Upload'
        steps:
          # ========== Step 1: Download and Extract NuGet Packages ==========
          - task: NuGetAuthenticate@1
            displayName: 'NuGet authentication'

          - task: NuGetToolInstaller@1
            displayName: 'Install NuGet'
            inputs:
              versionSpec: '6.x'

          - task: PowerShell@2
            displayName: 'Create directory structure'
            inputs:
              targetType: 'inline'
              script: |
                New-Item -ItemType Directory -Force -Path $(NugetsPath)
                New-Item -ItemType Directory -Force -Path $(NugetsPathNoVer)
                Write-Host "Directories created successfully"

          - task: PowerShell@2
            displayName: 'Verify NuGet configuration files'
            inputs:
              targetType: 'inline'
              script: |
                if (-not (Test-Path "$(NugetConfigsPath)\$(MsAppVersion).csproj")) {
                  Write-Error "$(MsAppVersion).csproj not found in $(NugetConfigsPath)!"
                  exit 1
                }
                if (-not (Test-Path "$(NugetConfigsPath)\nuget.config")) {
                  Write-Error "nuget.config not found in $(NugetConfigsPath)!"
                  exit 1
                }
                Write-Host "NuGet configuration files found in $(NugetConfigsPath)"

          # MS NugEt packages do not support NuGet restore task, use Powershell
          - task: PowerShell@2
            displayName: 'NuGet install Packages'
            continueOnError: true   
            inputs:
              targetType: 'inline'
              script: |
                nuget.exe restore $(NugetConfigsPath)\$(MsAppVersion).csproj -ConfigFile $(NugetConfigsPath)\nuget.config -OutputDirectory $(NugetsPath)
                exit 0
              errorActionPreference: 'silentlyContinue'
              warningPreference: 'silentlyContinue'
              

          # Debug: Inspect NuGet packages structure
          - task: PowerShell@2
            displayName: 'Debug - Inspect NuGet packages structure'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host ""
                Write-Host "============================================" -ForegroundColor Cyan
                Write-Host "DEBUG: NuGet Packages Structure" -ForegroundColor Cyan
                Write-Host "============================================" -ForegroundColor Cyan
                Write-Host "NugetsPath: $(NugetsPath)" -ForegroundColor Yellow
                
                if (Test-Path "$(NugetsPath)") {
                  $packages = Get-ChildItem -Path "$(NugetsPath)" -Directory
                  Write-Host "Found $($packages.Count) packages:" -ForegroundColor Yellow
                  foreach ($pkg in $packages) {
                    Write-Host ""
                    Write-Host "üì¶ Package: $($pkg.Name)" -ForegroundColor Green
                    
                    # Check version folders
                    $versionDirs = Get-ChildItem -Path $pkg.FullName -Directory
                    Write-Host "   Version folders: $($versionDirs.Count)" -ForegroundColor White
                    foreach ($ver in $versionDirs) {
                      Write-Host "   ‚îî‚îÄ‚îÄ $($ver.Name)" -ForegroundColor Gray
                      
                      # Check for ref folder
                      $refPath = Join-Path $ver.FullName "ref"
                      if (Test-Path $refPath) {
                        Write-Host "       ‚úÖ ref folder exists" -ForegroundColor Green
                        
                        # Check for net40 folder
                        $net40Path = Join-Path $refPath "net40"
                        if (Test-Path $net40Path) {
                          Write-Host "          ‚úÖ net40 folder exists" -ForegroundColor Green
                          
                          # List contents
                          $contents = Get-ChildItem -Path $net40Path -Directory
                          Write-Host "          Contains $($contents.Count) folders:" -ForegroundColor White
                          foreach ($item in $contents) {
                            Write-Host "             - $($item.Name)" -ForegroundColor Cyan
                          }
                        } else {
                          Write-Host "          ‚ùå net40 folder NOT found" -ForegroundColor Red
                        }
                      } else {
                        Write-Host "       ‚ùå ref folder NOT found" -ForegroundColor Red
                        Write-Host "       Contents of $($ver.Name):" -ForegroundColor Yellow
                        Get-ChildItem -Path $ver.FullName | ForEach-Object {
                          Write-Host "         - $($_.Name)" -ForegroundColor Gray
                        }
                      }
                    }
                  }
                } else {
                  Write-Host "‚ùå NugetsPath does not exist!" -ForegroundColor Red
                }
                Write-Host ""
                Write-Host "============================================" -ForegroundColor Cyan

          # Exclude version from NuGet packages and put all metadata folders together
          - task: PowerShell@2
            displayName: 'Exclude version from MS NuGet Packages'
            inputs:
              targetType: 'inline'
              script: |
                New-Item -ItemType Directory $(NugetsPathNoVer)\net40 -Force
                New-Item -ItemType Directory $(NugetsPathNoVer)\tools -Force
                
                Write-Host "Extracting metadata from NuGet packages..." -ForegroundColor Cyan
                
                # Get all packages (case-insensitive)
                $allPackages = Get-ChildItem -Path "$(NugetsPath)" -Directory
                
                foreach ($pkg in $allPackages) {
                  Write-Host "Processing package: $($pkg.Name)" -ForegroundColor Yellow
                  
                  # Get version folders
                  $versionDirs = Get-ChildItem -Path $pkg.FullName -Directory
                  
                  foreach ($ver in $versionDirs) {
                    # Check for ref\net40 folder
                    $refNet40Path = Join-Path $ver.FullName "ref\net40"
                    
                    if (Test-Path $refNet40Path) {
                      Write-Host "  Found ref\net40 in $($ver.Name)" -ForegroundColor Green
                      
                      # Copy all model folders from ref\net40 to net40
                      $models = Get-ChildItem -Path $refNet40Path -Directory
                      foreach ($model in $models) {
                        $destPath = Join-Path "$(NugetsPathNoVer)\net40" $model.Name
                        Write-Host "    Copying model: $($model.Name)" -ForegroundColor White
                        Copy-Item -Path $model.FullName -Destination $destPath -Recurse -Force
                      }
                    }
                  }
                }
                
                # Extract compiler tools
                Write-Host "Extracting compiler tools..." -ForegroundColor Cyan
                $compilerPkgs = Get-ChildItem -Path "$(NugetsPath)" -Directory | Where-Object { $_.Name -match "CompilerPackage" }
                foreach ($pkg in $compilerPkgs) {
                  $versionDirs = Get-ChildItem -Path $pkg.FullName -Directory
                  foreach ($ver in $versionDirs) {
                    Get-ChildItem -Path $ver.FullName -Recurse | Copy-Item -Destination "$(NugetsPathNoVer)\tools" -Recurse -Force -ErrorAction SilentlyContinue
                  }
                }
                
                Write-Host "Extraction completed!" -ForegroundColor Green

          - task: PowerShell@2
            displayName: 'Verify extracted NuGet packages structure'
            inputs:
              targetType: 'inline'
              script: |
                # Verify metadata structure (check if AxClass folders exist)
                Write-Host ""
                Write-Host "============================================" -ForegroundColor Cyan
                Write-Host "Verifying Metadata Content" -ForegroundColor Cyan
                Write-Host "============================================" -ForegroundColor Cyan
                $net40Path = "$(NugetsPathNoVer)\net40"
                if (Test-Path $net40Path) {
                  $models = Get-ChildItem -Path $net40Path -Directory
                  Write-Host "Found $($models.Count) models in net40:" -ForegroundColor Yellow
                  foreach ($model in $models) {
                    Write-Host "  üì¶ $($model.Name)" -ForegroundColor Green
                    $hasAxClass = Test-Path "$($model.FullName)\AxClass"
                    $hasAxTable = Test-Path "$($model.FullName)\AxTable"
                    $hasAxEnum = Test-Path "$($model.FullName)\AxEnum"
                    if ($hasAxClass) { Write-Host "    ‚úÖ AxClass folder found" -ForegroundColor Green }
                    if ($hasAxTable) { Write-Host "    ‚úÖ AxTable folder found" -ForegroundColor Green }
                    if ($hasAxEnum) { Write-Host "    ‚úÖ AxEnum folder found" -ForegroundColor Green }
                    if (-not ($hasAxClass -or $hasAxTable -or $hasAxEnum)) {
                      Write-Host "    ‚ö†Ô∏è  No metadata folders found" -ForegroundColor Yellow
                    }
                  }
                }
                Write-Host ""
                Write-Host "============================================" -ForegroundColor Cyan

          # Download d365fo-mcp-server from GitHub
          - task: PowerShell@2
            displayName: 'Download d365fo-mcp-server from GitHub'
            inputs:
              targetType: 'inline'
              script: |
                New-Item -Force -Path $(Build.SourcesDirectory) -Name "d365fo-mcp-server" -ItemType directory | Out-Null
                Invoke-WebRequest 'https://github.com/dynamics365ninja/d365fo-mcp-server/archive/refs/heads/main.zip' -OutFile $(Build.SourcesDirectory)\d365fo-mcp-server\d365fo-mcp-server.zip
                Expand-Archive $(Build.SourcesDirectory)\d365fo-mcp-server\d365fo-mcp-server.zip $(Build.SourcesDirectory)\d365fo-mcp-server\ | Write-Output
        
          # ========== Step 2: Extract Standard Metadata ==========
          
          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: $(nodeVersion)

          - script: npm ci
            displayName: 'Install NPM dependencies'
            workingDirectory: '$(Build.SourcesDirectory)/d365fo-mcp-server/d365fo-mcp-server-main'

          - script: npm run extract-metadata
            displayName: 'Extract standard metadata from NuGet packages'
            workingDirectory: '$(Build.SourcesDirectory)/d365fo-mcp-server/d365fo-mcp-server-main'
            env:
              PACKAGES_PATH: $(NugetsPathNoVer)\net40
              METADATA_PATH: $(Build.SourcesDirectory)\d365fo-mcp-server\d365fo-mcp-server-main\extracted-metadata
              EXTRACT_MODE: 'standard'

          # ========== Step 3: Extract Custom Metadata ==========

          - script: npm run extract-metadata
            displayName: 'Extract custom metadata from Git source'
            workingDirectory: '$(Build.SourcesDirectory)/d365fo-mcp-server/d365fo-mcp-server-main'
            env:
              PACKAGES_PATH: $(Pipeline.Workspace)\d365fo-source
              METADATA_PATH: $(Build.SourcesDirectory)\d365fo-mcp-server\d365fo-mcp-server-main\extracted-metadata
              EXTRACT_MODE: 'custom'
              CUSTOM_MODELS: $(CUSTOM_MODELS)
              EXTENSION_PREFIX: $(EXTENSION_PREFIX)

          # ========== Step 4: Build Database ==========
          
          - script: npm run build-database
            displayName: 'Build database (standard + custom)'
            workingDirectory: '$(Build.SourcesDirectory)/d365fo-mcp-server/d365fo-mcp-server-main'
            env:
              METADATA_PATH: $(Build.SourcesDirectory)\d365fo-mcp-server\d365fo-mcp-server-main\extracted-metadata
              DB_PATH: $(Build.SourcesDirectory)\d365fo-mcp-server\d365fo-mcp-server-main\data\xpp-metadata.db

          # ========== Step 5: Upload Everything to Blob Storage ==========

          - script: npm run blob-manager upload-all
            displayName: 'Upload all metadata (standard + custom) to blob'
            workingDirectory: '$(Build.SourcesDirectory)/d365fo-mcp-server/d365fo-mcp-server-main'
            env:
              AZURE_STORAGE_CONNECTION_STRING: $(AZURE_STORAGE_CONNECTION_STRING)
              BLOB_CONTAINER_NAME: $(BLOB_CONTAINER_NAME)
              METADATA_PATH: $(Build.SourcesDirectory)\d365fo-mcp-server\d365fo-mcp-server-main\extracted-metadata

          - script: npm run blob-manager upload-database $(Build.SourcesDirectory)\d365fo-mcp-server\d365fo-mcp-server-main\data\xpp-metadata.db
            displayName: 'Upload compiled database to blob'
            workingDirectory: '$(Build.SourcesDirectory)/d365fo-mcp-server/d365fo-mcp-server-main'
            env:
              AZURE_STORAGE_CONNECTION_STRING: $(AZURE_STORAGE_CONNECTION_STRING)
              BLOB_CONTAINER_NAME: $(BLOB_CONTAINER_NAME)
              DB_PATH: $(Build.SourcesDirectory)\d365fo-mcp-server\d365fo-mcp-server-main\data\xpp-metadata.db

          # ========== Step 6: Restart App Service ==========

          - task: AzureAppServiceManage@0
            displayName: 'Restart App Service to load new database'
            inputs:
              azureSubscription: '$(AZURE_SUBSCRIPTION)'
              action: 'Restart Azure App Service'
              webAppName: '$(AZURE_APP_SERVICE_NAME)'

          - task: PowerShell@2
            displayName: 'Platform upgrade completed'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host ""
                Write-Host "============================================" -ForegroundColor Green
                Write-Host "D365 Platform Upgrade Completed!" -ForegroundColor Green
                Write-Host "============================================" -ForegroundColor Green
                Write-Host ""
                Write-Host "‚úÖ Standard metadata: Latest version from NuGet (10.0.* and 7.0.*)"
                Write-Host "‚úÖ Custom metadata: Extracted"
                Write-Host "‚úÖ Database: Built and uploaded"
                Write-Host "‚úÖ App Service: Restarted"
                Write-Host ""
                Write-Host "Your MCP server is now running with the latest D365 version"
                Write-Host "============================================"
